
% Example program, for off-line processing of saved laser scans. 
% Example source code, useful for Task01. 
% AAS - 2018.S1.
% Jose Guivant.

% Note: Plotting of results is implemented, here, via a brute force approach.
% See other provided examples, for better implementation (dynamic updates using "set()").
% I expect you to avoid "brute force" implementations, in your projects. 


function MyProgram(DataFileName)

clc(); close all;
% In case the caller does not specify the input argument, we propose a default one.
if ~exist('DataFileName','var'), DataFileName ='Laser__2.mat'; end;

% load data file.
load(DataFileName); 
% The variable that contains the data structure is named "dataL"
% (because it was created under that name and saved)  

N = dataL.N;                         % number of scans in this squence.

disp('Brute force plotting');
disp('There is no GUI. Use "Control-C" to break the loop.');

for i=1:3:N,                        % in this example, I skip some of them..
    scan_i = dataL.Scans(:,i);
    ProcessScan(scan_i);
    
    s=sprintf('(Brute force plotting...)\nShowing scan #[%d]/[%d]\r',i,N);
    title(s);
    
    pause(0.01) ;                   % wait for ~10ms
end;
disp('Done. Bye.');

return;
end


%.............................
function ProcessScan(scan)

% Extract range and intensity information, from raw measurements.
% Each "pixel" is represented by its range and intensity of reflection.
% It is a 16 bits number whose bits 0-12 define the distance (i.e. the range)
% in cm (a number 0<=r<2^13), and bits 13-15 indicate the intensity 
%( a number 0<=i<8 ).

% We extract range and intensity, here.
%useful masks, for dealing with bits.
mask1FFF = uint16(2^13-1);
maskE000 = bitshift(uint16(7),13)  ;

intensities = bitand(scan,maskE000);

ranges    = single(bitand(scan,mask1FFF))*0.01; 
% Ranges expressed in meters, and unsing floating point format (e.g. single).

% 2D points, expressed in Cartesian. From the sensor's perpective.
angles = [0:360]'*0.5* pi/180 ;         % associated angle, for each individual range in a scan
X = cos(angles).*ranges;
Y = sin(angles).*ranges;    

% Plot. "BRUTE FORCE" plot (see note 1).
figure(1) ; clf(); hold on;
plot(X,Y,'b.');                     % all points
ii = find(intensities~=0);          % find those "pixels" that had intense reflection (>0) (aka: Highly Reflective pixels, HR)
plot(X(ii),Y(ii),'+r');             % plot highly reflective ones
axis([-10,10,0,20]);                % focuses plot on this region ( of interest in L220)

% Evaluate Clustering by using following function.
% Comment the function after finding the optimal cluster number.
% Optimal found numer clusters: k = 14
% evaluateClustering(X, Y, intensities)

% Extract Objects of interests
OOIs = ExtractOOIs(X, Y, intensities) ;
PlotOOIs(OOIs);

return;
end

function r = ExtractOOIs(X, Y, intensities)
    n_points = size(X,1);
    r.N = 0;
    r.Centers = [];
    r.Diameters
   = [];
    r.Color = [];
    r.circle_MSE = [];
    r.p_c = {};
    i = 1;
    X_ = X;
    Y_ = Y;
    finished = false;
    idxs = 1:size(X,1);
    while ~finished
        [Success, finished, Centers, Sizes, p_c, intensities_c, next_idx] = ...
                                       extractCluster(X_, Y_, intensities);
        
        
        if Success
            r.N = r.N + Success;
            r.Centers = [r.Centers; Centers];
            r.p_c(r.N) = {p_c};
            r.Sizes = [r.Sizes; Sizes];
        end
        
        X_ = X_(next_idx:end, :);
        Y_ = Y_(next_idx:end, :);
        intensities = intensities(next_idx:end);
        idxs = idxs(next_idx:end);
        r.Color = [r.Color; any(intensities_c > 0)];
    end
    
    
    % Cirlce fitting
    sizes_circle_fitting = [];
    for i = 1:r.N
        n = size(r.p_c{i},1);
        par = CircleFitByPratt(r.p_c{i});
        x_m = par(1);
        y_m = par(2);
        r_m = par(3);
        sizes_circle_fitting = [sizes_circle_fitting;...
                                r_m*2];
        circle_MSE = abs( (r_m).^2 - ((r.p_c{i}(:,1) - x_m) .^2 + ...
                                       (r.p_c{i}(:,2) - y_m) .^2 ));
%         circle_MSE = abs((r.Sizes(i) * 0.5).^2 - ( (r.p_c{i}(:,1) - r.Centers(i,1)) .^2 + ...
%                                         (r.p_c{i}(:,2) - r.Centers(i,2)) .^2 ));
        r.circle_MSE = [r.circle_MSE ; sum(circle_MSE)/n];
        
    end
    
%   Within Radius
    size_range = [0.05 0.2];
    mask = sizes_circle_fitting < size_range(2) & ...
                           sizes_circle_fitting > size_range(1);
    scatter(r.Centers(mask(:),1), r.Centers(mask(:),2),'ks')
    
%     Smalles MSE
%     k = 10;
%     sizes_circle_fitting = sizes_circle_fitting(sizes_circle_fitting<0.2]
%     [mse_sorted idx] = sort(r.circle_MSE,'ascend');
%     p_smallest = r.Centers(idx(1:k),:);
%     scatter(p_smallest(:,1), p_smallest(:,2),'ks');

%     Distance between centers
%     dists_c = pdist(r.Centers);
%     dists_c = squareform(dists_c);
%     neighbs = [diag(dists_c,-1) diag(dists_c,1)];
%     mask = sum(neighbs>1.5, 2) == 2;
%     scatter(r.Centers(mask(:),1), r.Centers(mask(:),2),'ks')


end
    
function PlotOOIs(OOIs)
    if OOIs.N<1, return ; end;
        scatter(OOIs.Centers(:,1), OOIs.Centers(:,2),'g*')
return;
end
    
% --------------------------------
% note 1: for a more efficient way of dynamically plotting, see example
% "ExampleUseLaserData.m", where we used graphical objects handles.
% --------------------------------
% Questions?  Ask the lecturer, j.guivant@unsw.edu.au
% --------------------------------
